function [dense_verts, time_space_polytopes_with_dense_verts] = fcn_interpolate_polytopes_in_time(time_space_polytopes,dt)
% fcn_interpolate_polytopes_in_time
% Adds nodes to the input polytopes to increase the density of nodes in the
% time (z) dimension so that the planner has more options of where to route.
%
%
%
% FORMAT:
%
% [dense_verts, time_space_polytopes_with_dense_verts] = fcn_interpolate_polytopes_in_time(time_space_polytopes,dt)
%
% INPUTS:
%
%     time_space_polytopes: a struct array with a vertices field holding the vertices of each polytope
%     vertices consists of 4 columns: x position, y position, time (z-axis position) and vertex id
%     the vertex ID is necessary for correctly mapping a vertex at one time to its position at the next time
%     dt: the desired time step for interpolating the polytope vertices
%
%
% OUTPUTS:
%
%      dense_verts: matrix of all vertices in the polytope field, after interpolation
%
%      time_space_polytopes_with_dense_verts: time_space_polytopes input struct array, replicated with
%      a new field called dense_verts_this_poly representing the interpolated vertices for each polytope
%
% DEPENDENCIES:
% generally, the input for this function can be generated by fcn_make_timespace_polyhedra_from_polygons
% but this is not a strictly necessary dependency
% see script_test_3d_polytope_multiple or the readme for an example of the typical call order
%
% EXAMPLES:
%
% See the script: script_test_3d_polytope_multiple
% for a full test suite.
%
% This function was written on summer 2023 by Steve Harnett
% Questions or comments? contact sjharnett@psu.edu

%
% REVISION HISTORY:
%
% 2023, summer by Steve Harnett
% -- first write of function
%
% TO DO:
% TODO @sjharnett when functionalizing this, add the vertex ID column but then remove it

    dense_verts = [];
    time_space_polytopes_with_dense_verts = time_space_polytopes;
    % loop through each polytope in input struct array
    for i = 1:length(time_space_polytopes)
        verts_this_poly = time_space_polytopes(i).vertices;
        dense_verts_this_poly = INTERNAL_fcn_interpolate_polytope_in_time(verts_this_poly,dt);
        % save interpolated vertices on this polytope
        time_space_polytopes_with_dense_verts(i).dense_vertices = dense_verts_this_poly;
        % save interpolated vertices in all verts array
        dense_verts = [dense_verts; dense_verts_this_poly];
    end
end

function dense_verts = INTERNAL_fcn_interpolate_polytope_in_time(verts,dt)

    % for number of unique time values in verts...
    unique_times = unique(verts(:,3));
    num_unique_times = length(unique(verts(:,3)));

    unique_verts = unique(verts(:,4));
    num_unique_verts = length(unique(verts(:,4)));

    % first, linearly interpolated between existing timestamps
    dense_times = [];
    for i = 2:1:num_unique_times
        new_times = unique_times(i-1):dt:unique_times(i);
        dense_times = [dense_times; new_times'];
    end
    dense_times = unique(dense_times); % remove any duplicates
    num_dense_times = length(dense_times);

    % for each vertex, want to interpolate x and y position by the dense times
    for i = 1:1:num_unique_verts
        this_vert_id = unique_verts(i);
        this_vert_rows = find(verts(:,4)==this_vert_id); % find this vertex through all time via its ID
        % extract this vertex's x, y, and t information
        this_vert_x = verts(this_vert_rows,1);
        this_vert_y = verts(this_vert_rows,2);
        this_vert_t = verts(this_vert_rows,3);
        % use MATLABs linear interpolation function to interpolate both x and y position along dense_times
        this_vert_dense_x = interp1(this_vert_t,this_vert_x,dense_times);
        this_vert_dense_y = interp1(this_vert_t,this_vert_y,dense_times);
        this_vert_id_repeated = this_vert_id*ones(num_dense_times,1);
        verts = [verts; this_vert_dense_x this_vert_dense_y dense_times this_vert_id_repeated];
    end
    dense_verts = verts;
end
