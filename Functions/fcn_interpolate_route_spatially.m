function route_dense = fcn_interpolate_route_spatially(route,num_pts)
% fcn_interpolate_route_spatially
%
% Adds waypoints to the input route to increase the density of points according to the number of
% desired points. This is useful for threadpulling (replanning from waypoints along an initial route).
%
%
% FORMAT:
%
% route_dense = fcn_interpolate_route_spatially(route,num_pts)
%
% INPUTS:
%
%     route: the matrix as produced by fcn_algorithm_Astar3d consisting of waypoints.  Each row is a
%     waypoint, and each column is x, y, t, and point ID
%
%     num_pts: the desired number of points to add when creating the dense route by interpolating the route waypoints
%
% OUTPUTS:
%     route_dense: the matrix representing the interpolated route consisting of waypoints.  Each row is a
%     waypoint, and each column is x, y, and point ID
%
% DEPENDENCIES:
% generally, the input for this function can be generated by fcn_algorithm_Astar or fcn_algorithm_bound_Astar
% but this is not a strictly necessary dependency
%
% EXAMPLES:
%
% See the script: script_test_fcn_interpolate_route_spatially
% for a full test suite.
%
% This function was written in Janyuary 2024 by Steve Harnett
% Questions or comments? contact sjharnett@psu.edu

%
% REVISION HISTORY:
%
% 2024, January by Steve Harnett
% -- first write of function
%
% TO DO:

    % loop through each pair of waypoints
    % if the x's aren't the same, interpolate normally BASED ON DISTANCE
    % if the x's are the same, interpolate in y instead
    % assemble waypoints
    % that's it
    % see fcn_MapGen_increasePolytopeVertexCount


    %% interpolation code for a route
    start = route(1,:);
    finish = route(end,:);
    route_dense_x = linspace(start(1),finish(2),num_pts);
    % add the original x values to the interpolated x values so the original
    % route waypoints are preserved.  Remove any duplicates that were introduced
    % as a result of this concatenation.
    route_dense_x = unique(sort([route_dense_x, (route(:,1))']));

    num_route_verts = size(route,1);

    % first, linearly interpolated between existing timestamps
    % dense_times = [];
    % for i = 2:1:num_unique_times
    %     new_times = unique_times(i-1):dt:unique_times(i);
    %     dense_times = [dense_times; new_times'];
    % end
    % dense_times = unique(dense_times); % remove duplicates
    % num_dense_times = length(dense_times);


    % for each waypoint, want to interpolate x and y position by the dense times
    try
        route_dense_y = interp1(route(:,1),route(:,2),route_dense_x);
    catch
        % interpolation may fail if the route has a stationary segment
        error('route may have repeated waypoint')
    end
    % create a new route based on the more dense waypoints
    route_dense = [route_dense_x route_dense_y];
end
