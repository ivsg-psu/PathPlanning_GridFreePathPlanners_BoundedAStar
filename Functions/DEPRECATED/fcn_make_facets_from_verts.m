function time_space_polytopes_with_facets = fcn_make_facets_from_verts(time_space_polytopes)
% fcn_make_facets_from_verts
%
% Takes a timespace or 3D polytope, defined by its vertices, and associates these vertices
% into facets (the 2D faces of the 3D shape) so it is clear how the vertices should be connected by plane segments.
%
%
%
% FORMAT:
%
% time_space_polytopes_with_facets = fcn_make_facets_from_verts(time_space_polytopes)
%
% INPUTS:
%
%   time_space_polytopes: the 3D (XYT) polytope struct array of the form generated by the function
%   fcn_make_timespace_polyhedra_from_polygons i.e. a struct array with a verts field holding the vertices of each polytope
%   vertices consists of 4 columns: x position, y position, time (z-axis position) and vertex id
%   the vertex ID is necessary for correctly mapping a vertex at one time to its position at the next time
%
%
% OUTPUTS:
%
%     time_space_polytopes_with_facets: a struct array with the following fields:
%       vertices: field holding the vertices of each polytope
%           vertices consists of 4 columns: x position, y position, time (z-axis position) and vertex id
%           the vertex ID is necessary for correctly mapping a vertex at one time to its position at the next time
%       flats: field associating vertices into flat facets (i.e. facets that lie flat in a single time plane)
%       sides: field associating vertices into side wall facets (i.e. facets that can span several time values)
%       both the flats and sides fields have the same format: a matrix where each row is a facet and every 4 columns
%         is one vertex consisting of (x, y, t, and ID) as stated above
%         e.g. two flats with three vertices each would be represented as the following 2x12 matrix:
%         flat 1, vert 1 x, flat 1 vert 1 y, flat 1 vert 1 t, flat 1 vert 1 ID, ..., flat 1, vert 3 x, flat 1 vert 3 y, flat 1 vert 3 t, flat 1 vert 3 ID
%         flat 2, vert 1 x, flat 2 vert 1 y, flat 2 vert 1 t, flat 2 vert 1 ID, ..., flat 2, vert 3 x, flat 2 vert 3 y, flat 2 vert 3 t, flat 2 vert 3 ID
%
%
% DEPENDENCIES:
% generally, the input for this function can be generated by fcn_make_timespace_polyhedra_from_polygons
% but this is not a strictly necessary dependency
% see script_test_3d_polytope_multiple or the readme for an example of the typical call order
% there are no dependencies in the source code of this function
%
% EXAMPLES:
%
% See the script: script_test_3d_polytope_multiple
% for a full test suite.
%
% This function was written on summer 2023 by Steve Harnett
% Questions or comments? contact sjharnett@psu.edu

%
% REVISION HISTORY:
%
% 2023, summer by Steve Harnett
% -- first write of function
%
% TO DO:
%
% -- fill in to-do items here.

    % loop through all polytopes
    for i = 1:length(time_space_polytopes)
        verts = time_space_polytopes(i).vertices; % pull out vertices
        unique_times = unique(verts(:,3)); % the number of unique t values in the vertices...
        num_unique_times = length(unique_times); % is the number of time stamps for which there is data

        unique_verts = unique(verts(:,4)); % the number of unique ID values in column 4 of the vertices...
        num_unique_verts = length(unique_verts); % is the number of unique vertices

        % both flats and sides are the number of facets X (number of pts*4)
        % this is because each point is 4-dimensional (x,y,t,id)
        % initialize flats as num times (one flat per time) X num verts*4
        % (each vertex is required to define a flat polygon)
        flats = nan(num_unique_times,num_unique_verts*4);

        % there is a side for ever pair of verts and every pair of times
        % this is because a pair of vertices at one time, representing a line segment side on the 2D polytope,
        % will move to a new time, thus the line segment at the next time forms a parallelogram in time space
        % these always have 4 points so the sides is initialized as
        % (num verts * num times - 1) X 4*4
        % (for four 4-dimensional points (x,y,t,id))
        sides = nan(num_unique_verts*(num_unique_times-1), 4*4);
        sides_recorded = 1; % initialize counter of number of sides recorded

        % put 2D polytope at first time into flats array
        this_time_rows = find(verts(:,3) == unique_times(1)); % find vertices with the first unique timestamp
        flats(1,:) = reshape(verts(this_time_rows,:).',1,[]); % put all vertices onto one row

        % loop through remaining time stamps
        for j = 2:num_unique_times
            % put this time into flats array
            prev_time = unique_times(j-1);
            this_time = unique_times(j);
            this_time_rows = find(verts(:,3) == this_time); % find vertices at current time
            prev_time_rows = find(verts(:,3) == prev_time); % find vertices at previous time
            % make another flat from vertices at the current time
            flats(j,:) = reshape(verts(this_time_rows,:).',1,[]); % put all vertices onto one row

            % loop through all unique vertices
            for k = 1:num_unique_verts
            % for each vertex, take this vert to the next...
                this_vert = unique_verts(k);
                if k == num_unique_verts
                    next_vert = unique_verts(1); % next vert is the first vert if we're looking at the last vert (circular array)
                else
                    next_vert = unique_verts(k+1); % otherwise next vert is the kth + 1 vert
                end
                this_vert_rows = find(verts(:,4) == this_vert); % find vertices with the same vertex ID (representing the same vertex at other times)
                next_vert_rows = find(verts(:,4) == next_vert);
                % ...at this time to the previous
                % forming the parallelogram of this side of the 2D polytope at the previous time to the next time
                side_wall_idx = [(intersect(this_vert_rows, prev_time_rows)),...
                                 (intersect(next_vert_rows, prev_time_rows)),...
                                 (intersect(next_vert_rows, this_time_rows)),...
                                 (intersect(this_vert_rows, this_time_rows))];

                % and put that in the array of sidewalls
                sides(sides_recorded,:) = reshape(verts(side_wall_idx,:).',1,[]);
                sides_recorded = sides_recorded + 1; % increment side counter after recording a side
            end
        end
        time_space_polytopes(i).flats = flats; % update this polytope with flats matrix
        time_space_polytopes(i).sides = sides; % update this polytope with sides matrix
    end
    time_space_polytopes_with_facets = time_space_polytopes; % rename for output
end
