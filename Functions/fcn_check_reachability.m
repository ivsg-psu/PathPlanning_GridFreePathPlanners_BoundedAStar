function [is_reachable, num_steps, rgraph_total] = fcn_check_reachability(vgraph,start,finish)
 % fcn_check_reachability 
 % 
 % From the visibility graph describing node visible from each node,
 % finds and analyzes the reachability graph describing nodes that have a valid
 % multistep route from each node
 % 
 % 
 % 
 % FORMAT: 
 % [is_reachable, num_steps, rgraph_total] = fcn_check_reachability(vgraph,start,finish)
 %  
 % 
 % INPUTS: 
 % 
 %   shrunk_polytopes: the 2D polytope struct array of the form generated by the MapGen repo, typically 
 %   generated with the functions fcn_MapGen_haltonVoronoiTiling and fcn_MapGen_polytopesShrink* 
 %   see MapGen repo for examples of how to generate polytope maps with these functions 
 % 
 %   max_translation_distance: the maximum distance any polytope will be allowed to translate from 
 %   time = 0 to the final time.  If this is set at half the gap size, no polytope collisions will occur 
 % 
 %   final_time: the end time of the timespace polytopes.  This is the maximum t-axis (z-axis) value 
 % 
 % 
 % OUTPUTS: 
 % 
 %     time_space_polytopes: a struct array with a vertices field holding the vertices of each polytope 
 %     vertices consists of 4 columns: x position, y position, time (z-axis position) and vertex id 
 %     the vertex ID is necessary for correctly mapping a vertex at one time to its position at the next time 
 % 
 % DEPENDENCIES: 
 % 
 % the repo PathPlanning_MapTools_MapGenClassLibrary is used for creating the inputs to this function 
 % but there are no dependencies in the source code of this function 
 % 
 % EXAMPLES: 
 % 
 % See the script: script_test_3d_polytope_multiple 
 % for a full test suite. 
 % 
 % This function was written on summer 2023 by Steve Harnett 
 % Questions or comments? contact sjharnett@psu.edu 
  
 % 
 % REVISION HISTORY: 
 % 
 % 2023, summer by Steve Harnett 
 % -- first write of function 
 % 
 % TO DO: 
 % 
 % -- fill in to-do items here.
    num_pts = size(vgraph,1);
    start_id = start(4);
    finish_id = finish(:,4);
    start_id_repeated = ones(size(finish_id,1),size(finish_id,2))*start_id;
    is_reachable = 0;
    rgraph_total = zeros(num_pts);
    for num_steps = 1:num_pts
        rgraph = vgraph^num_steps;
        rgraph_total = rgraph_total + rgraph;
        ind = sub2ind([num_pts,num_pts],start_id_repeated,finish_id);
        if sum(rgraph(ind)) > 0
            is_reachable = 1;
        end
    end
    rgraph_total = (rgraph_total>0); % make rgraph binary
end
